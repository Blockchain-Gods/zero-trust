use anyhow::{anyhow, Result};
use risc0_zkvm::{default_prover, ExecutorEnv, InnerReceipt, ProverOpts, Receipt};
use sha2::{Digest, Sha256};

// Generated by `cargo risczero build` — replace with your actual crate name
use methods::{GUEST_ZEROTRUST_ZKVM_ELF, GUEST_ZEROTRUST_ZKVM_ID};
use stellar_xdr::curr::Limited;
use base64::{Engine, engine::general_purpose::STANDARD};

// ─── Stellar constants ────────────────────────────────────────────────────────

pub const TESTNET_CONTRACT_ID: &str =
    "CBSTBYNBRPSQWSDDVFEBYDQNLKQWINVCT4AGHQ4FN2W7F6H6ESQUKXRX";
pub const TESTNET_NETWORK_PASSPHRASE: &str = "Test SDF Network ; September 2015";
pub const TESTNET_RPC_URL: &str = "https://soroban-testnet.stellar.org";

// ─── Journal layout ───────────────────────────────────────────────────────────
// Matches what the guest program commits via env::commit_slice / env::commit
//
// Offset  Size  Field
// 0       4     challenge_id         (u32 LE)
// 4       32    player_pubkey        ([u8;32])
// 36      4     bot_config_id        (u32 LE)
// 40      4     threats_cured        (u32 LE)
// 44      4     systems_destroyed    (u32 LE)
// 48      4     data_leaked_x100     (u32 LE)  — e.g. 4550 = 45.50%
// 52      4     score                (u32 LE)
// 56      4     duration_ms          (u32 LE)
// 60      4     accuracy_bps         (u32 LE)
// ──────────────────────────────────────────────────────────────────────────────
pub const JOURNAL_LEN: usize = 64;

// ─── Types ────────────────────────────────────────────────────────────────────

/// Public outputs committed to by the guest — what gets posted on-chain.
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct GameJournal {
    pub challenge_id: u32,
    pub player_pubkey: [u8; 32],
    pub bot_config_id: u32,
    pub threats_cured: u32,
    pub systems_destroyed: u32,
    pub data_leaked_x100: u32, // percentage × 100, e.g. 4550 = 45.50%
    pub score: u32,
    pub duration_ms: u32,
    pub accuracy_bps: u32, // basis points, 10000 = 100%
}

/// Bot config fetched from Stellar and passed into the zkVM as a public input.
/// All floats converted to fixed-point integers (×100) to match on-chain storage.
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct BotConfigZK {
    pub bot_type: String,           // e.g. "malware"
    pub primary_target: String,     // e.g. "compute"
    pub secondary_targets: Vec<String>,
    pub damage_multiplier: u32,     // on-chain u32, e.g. 150 = 1.5×
    pub threat_count: u32,
    pub spawn_pattern: String,      // "steady" | "burst" | "crescendo"
    pub skill_diversity: String,    // "low" | "medium" | "high"
    pub victory_condition: String,  // "time_survival" | "system_destruction" | "data_exfiltration"
}

/// Action log entry — private input from defender.
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct ActionEntry {
    pub dev_index: u32,
    pub threat_index: u32,
    pub assigned_at_ms: u32,
    pub unassigned_at_ms: u32,
}

/// Full input to the prover.
#[derive(Debug, Clone)]
pub struct ProveInput {
    pub challenge_id: u32,
    pub player_pubkey: [u8; 32],
    pub bot_config_id: u32,
    pub bot_config: BotConfigZK,    // public — fetched from Stellar
    pub action_log: Vec<ActionEntry>, // private — only defender sees this
}

/// Everything the caller needs after proving.
#[derive(Debug, Clone)]
pub struct ProveResult {
    pub journal: GameJournal,
    pub journal_bytes: Vec<u8>,
    pub journal_sha256: [u8; 32],
    pub seal: Vec<u8>,
    pub image_id: [u8; 32],
}

// ─── Stellar bot config fetching ─────────────────────────────────────────────

/// Fetch bot config from the Stellar NFT contract given a token_id.
/// Uses env vars if set, otherwise falls back to hardcoded testnet values.
pub async fn fetch_bot_config_from_stellar(bot_config_id: u32) -> Result<BotConfigZK> {
    let rpc_url = std::env::var("STELLAR_RPC_URL")
        .unwrap_or_else(|_| TESTNET_RPC_URL.to_string());
    let contract_id = std::env::var("STELLAR_BOT_NFT_CONTRACT_ID")
        .unwrap_or_else(|_| TESTNET_CONTRACT_ID.to_string());

    // Build the Stellar RPC call: simulate get_bot_config(token_id)
    // Using raw RPC since we don't have the full Stellar SDK in Rust the same
    // way the TS client does — we call simulateTransaction directly.
    let client = reqwest::Client::new();

    // XDR-encode the invocation: get_bot_config with token_id arg
    // We build a minimal simulateTransaction body
    let invoke_body = serde_json::json!({
        "jsonrpc": "2.0",
        "id": 1,
        "method": "simulateTransaction",
        "params": {
            "transaction": build_simulate_tx(&contract_id, "get_bot_config", bot_config_id)?
        }
    });

    let resp = client
        .post(&rpc_url)
        .json(&invoke_body)
        .send()
        .await?
        .json::<serde_json::Value>()
        .await?;

    parse_bot_config_from_rpc_response(&resp, bot_config_id)
}

/// Builds a base64-encoded unsigned transaction envelope for simulateTransaction.
/// This calls get_bot_config(token_id) on the NFT contract.
fn build_simulate_tx(contract_id: &str, fn_name: &str, token_id: u32) -> Result<String> {
    use stellar_xdr::curr::{
        ContractId, Hash, HostFunction, InvokeContractArgs, Limits, ScAddress, ScSymbol, ScVal,
        ScVec, SorobanAuthorizationEntry, Transaction, TransactionEnvelope, TransactionExt,
        TransactionV1Envelope, Uint256, Memo, MuxedAccount, Operation, OperationBody,
        InvokeHostFunctionOp, WriteXdr, SequenceNumber, TimeBounds, TimePoint,
    };

    // Decode contract address from strkey
    let contract_bytes = stellar_strkey::Contract::from_string(contract_id)
        .map_err(|e| anyhow!("invalid contract id: {}", e))?
        .0;

    let contract_hash = Hash(contract_bytes);

    let fn_sym = ScSymbol(fn_name.try_into().map_err(|e| anyhow!("{:?}", e))?);

    let token_val = ScVal::U32(token_id);

    let invoke_args = InvokeContractArgs {
        contract_address: ScAddress::Contract(ContractId(contract_hash)),
        function_name: fn_sym,
        args: vec![token_val].try_into().map_err(|e| anyhow!("{:?}", e))?,
    };

    let host_fn = HostFunction::InvokeContract(invoke_args);

    let op = Operation {
        source_account: None,
        body: OperationBody::InvokeHostFunction(InvokeHostFunctionOp {
            host_function: host_fn,
            auth: vec![].try_into().map_err(|e| anyhow!("{:?}", e))?,
        }),
    };

    // Dummy source account (zero key) — fine for simulate
    let source = MuxedAccount::Ed25519(Uint256([0u8; 32]));

    let tx = Transaction {
        source_account: source,
        fee: 1_000_000,
        seq_num: SequenceNumber(1),
        cond: stellar_xdr::curr::Preconditions:: None,
        memo: Memo::None,
        operations: vec![op].try_into().map_err(|e| anyhow!("{:?}", e))?,
        ext: TransactionExt::V0,
    };

    let envelope = TransactionEnvelope::Tx(TransactionV1Envelope {
        tx,
        signatures: vec![].try_into().map_err(|e| anyhow!("{:?}", e))?,
    });

    let mut xdr_bytes = Vec::new();
let mut limited = Limited::new(&mut xdr_bytes, stellar_xdr::curr::Limits::none());
envelope.write_xdr(&mut limited)?;
   Ok(STANDARD.encode(&xdr_bytes))
}

/// Parses the simulateTransaction RPC response into a BotConfigZK.
fn parse_bot_config_from_rpc_response(
    resp: &serde_json::Value,
    token_id: u32,
) -> Result<BotConfigZK> {
    use stellar_xdr::curr::{ReadXdr, ScVal, Limits};

    let result_b64 = resp
        .pointer("/result/results/0/xdr")
        .and_then(|v| v.as_str())
        .ok_or_else(|| anyhow!("missing xdr in simulateTransaction response for token {}", token_id))?;

let xdr_bytes = STANDARD.decode(result_b64)?;
let mut limited = Limited::new(xdr_bytes.as_slice(), stellar_xdr::curr::Limits::none());
let sc_val = ScVal::read_xdr(&mut limited)?;

    // sc_val is a ScVal::Map representing the BotConfig struct
    extract_bot_config_from_scval(&sc_val)
}

fn extract_bot_config_from_scval(val: &stellar_xdr::curr::ScVal) -> Result<BotConfigZK> {
    use stellar_xdr::curr::ScVal;

    let map = match val {
        ScVal::Map(Some(m)) => m,
        _ => return Err(anyhow!("expected ScVal::Map for BotConfig")),
    };

    let mut bot_type = String::new();
    let mut primary_target = String::new();
    let mut secondary_targets: Vec<String> = vec![];
    let mut damage_multiplier: u32 = 100;
    let mut threat_count: u32 = 5;
    let mut spawn_pattern = String::new();
    let mut skill_diversity = String::new();
    let mut victory_condition = String::new();

    for entry in map.iter() {
        let key = match &entry.key {
            ScVal::Symbol(s) => s.0.to_string(),
            _ => continue,
        };

        match key.as_str() {
            "bot_type" => bot_type = scval_enum_tag(&entry.val)?,
            "primary_target" => {
                // Option<SystemTargetId> — may be ScVal::Void if None
                if let Ok(tag) = scval_enum_tag(&entry.val) {
                    primary_target = tag;
                }
            }
            "secondary_targets" => {
                secondary_targets = scval_vec_of_enum_tags(&entry.val)?;
            }
            "damage_multiplier" => {
                damage_multiplier = scval_u32(&entry.val)?;
            }
            "threat_count" => {
                threat_count = scval_u32(&entry.val)?;
            }
            "spawn_pattern" => spawn_pattern = scval_enum_tag(&entry.val)?,
            "skill_diversity" => skill_diversity = scval_enum_tag(&entry.val)?,
            "victory_condition" => victory_condition = scval_enum_tag(&entry.val)?,
            _ => {}
        }
    }

    Ok(BotConfigZK {
        bot_type: normalise_tag(&bot_type),
        primary_target: normalise_tag(&primary_target),
        secondary_targets: secondary_targets.into_iter().map(|s| normalise_tag(&s)).collect(),
        damage_multiplier,
        threat_count,
        spawn_pattern: normalise_tag(&spawn_pattern),
        skill_diversity: normalise_tag(&skill_diversity),
        victory_condition: normalise_tag_hyphen(&victory_condition),
    })
}

// ─── ScVal helpers ────────────────────────────────────────────────────────────

fn scval_enum_tag(val: &stellar_xdr::curr::ScVal) -> Result<String> {
    use stellar_xdr::curr::ScVal;
    match val {
        ScVal::Vec(Some(v)) if !v.is_empty() => match &v[0] {
            ScVal::Symbol(s) => Ok(s.0.to_string()),
            _ => Err(anyhow!("expected symbol as enum tag")),
        },
        ScVal::Symbol(s) => Ok(s.0.to_string()),
        _ => Err(anyhow!("expected ScVal::Vec or Symbol for enum")),
    }
}

fn scval_vec_of_enum_tags(val: &stellar_xdr::curr::ScVal) -> Result<Vec<String>> {
    use stellar_xdr::curr::ScVal;
    match val {
        ScVal::Vec(Some(v)) => v.iter().map(scval_enum_tag).collect(),
        ScVal::Void => Ok(vec![]),
        _ => Err(anyhow!("expected ScVal::Vec for secondary_targets")),
    }
}

fn scval_u32(val: &stellar_xdr::curr::ScVal) -> Result<u32> {
    use stellar_xdr::curr::ScVal;
    match val {
        ScVal::U32(n) => Ok(*n),
        _ => Err(anyhow!("expected ScVal::U32")),
    }
}

// Mirrors normaliseTag from the FE: "TimeSurvival" → "timesurvival"
fn normalise_tag(s: &str) -> String {
    s.to_lowercase()
}

// Mirrors normaliseTagHyphen: "LogicBomb" → "logic-bomb", "TimeSurvival" → "time-survival"
fn normalise_tag_hyphen(s: &str) -> String {
    let mut result = String::new();
    for (i, ch) in s.chars().enumerate() {
        if ch.is_uppercase() && i > 0 {
            result.push('-');
        }
        result.push(ch.to_lowercase().next().unwrap());
    }
    result
}

// ─── Core prove function ──────────────────────────────────────────────────────

pub fn prove_game(input: &ProveInput) -> Result<ProveResult> {
        log::info!("Starting proof generation for bot_config_id={} player={}", 
        input.bot_config_id,
        hex::encode(&input.player_pubkey[..4]) // first 4 bytes for brevity
    );


    let env = ExecutorEnv::builder()
        // Public inputs
        .write(&input.challenge_id)?
        .write(&input.player_pubkey)?
        .write(&input.bot_config_id)?
        .write(&input.bot_config)?
        // Private input — action log
        .write(&input.action_log)?
        .build()?;

          log::info!("Executor environment built, starting prover...");

    let prover = default_prover();
    let (opts, require_groth16) = prover_opts_from_env();

    let prove_info = prover.prove_with_opts(env, GUEST_ZEROTRUST_ZKVM_ELF, &opts)?;
    
    log::info!("Proof generated, verifying...");
    prove_info.receipt.verify(GUEST_ZEROTRUST_ZKVM_ID)?;
 log::info!("Receipt verified successfully");
 
    let receipt = prove_info.receipt;

    if require_groth16 && !matches!(&receipt.inner, InnerReceipt::Groth16(_)) {
        return Err(anyhow!(
            "expected Groth16 receipt; ensure Groth16 proving is enabled (Docker required)"
        ));
    }

    let journal_bytes = receipt.journal.bytes.clone();
    let journal = decode_journal(&journal_bytes)?;
    let journal_sha256 = sha256(&journal_bytes);
    let seal = receipt_seal_bytes(&receipt)?;
    let image_id = digest_to_bytes(GUEST_ZEROTRUST_ZKVM_ID.into());

    Ok(ProveResult {
        journal,
        journal_bytes,
        journal_sha256,
        seal,
        image_id,
    })
}

fn prover_opts_from_env() -> (ProverOpts, bool) {
    let kind = std::env::var("ZERO_TRUST_RECEIPT_KIND")
        .unwrap_or_else(|_| "groth16".to_string())
        .to_lowercase();

    match kind.as_str() {
        "succinct" => (ProverOpts::succinct(), false),
        "composite" => (ProverOpts::composite(), false),
        "groth16" | _ => (ProverOpts::groth16(), true),
    }
}

// ─── Journal encode / decode ──────────────────────────────────────────────────

pub fn decode_journal(bytes: &[u8]) -> Result<GameJournal> {
    if bytes.len() != JOURNAL_LEN {
        return Err(anyhow!(
            "journal length mismatch: got {}, expected {}",
            bytes.len(),
            JOURNAL_LEN
        ));
    }

    let mut o = 0usize;

    macro_rules! read_u32 {
        () => {{
            let v = u32::from_le_bytes(bytes[o..o + 4].try_into().unwrap());
            o += 4;
            v
        }};
    }

    macro_rules! read_bytes32 {
        () => {{
            let mut arr = [0u8; 32];
            arr.copy_from_slice(&bytes[o..o + 32]);
            o += 32;
            arr
        }};
    }

    let challenge_id = read_u32!();
    let player_pubkey = read_bytes32!();
    let bot_config_id = read_u32!();
    let threats_cured = read_u32!();
    let systems_destroyed = read_u32!();
    let data_leaked_x100 = read_u32!();
    let score = read_u32!();
    let duration_ms = read_u32!();
    let accuracy_bps = read_u32!();

    Ok(GameJournal {
        challenge_id,
        player_pubkey,
        bot_config_id,
        threats_cured,
        systems_destroyed,
        data_leaked_x100,
        score,
        duration_ms,
        accuracy_bps,
    })
}

// ─── Utilities ────────────────────────────────────────────────────────────────

pub fn sha256(data: &[u8]) -> [u8; 32] {
    let mut h = Sha256::new();
    h.update(data);
    h.finalize().into()
}

pub fn digest_to_bytes(digest: risc0_zkvm::sha::Digest) -> [u8; 32] {
    let mut out = [0u8; 32];
    out.copy_from_slice(digest.as_bytes());
    out
}

pub fn receipt_seal_bytes(receipt: &Receipt) -> Result<Vec<u8>> {
    match &receipt.inner {
        InnerReceipt::Groth16(inner) => Ok(inner.seal.clone()),
        InnerReceipt::Succinct(inner) => Ok(inner.get_seal_bytes()),
        InnerReceipt::Composite(inner) => {
            if inner.assumption_receipts.is_empty() && inner.segments.len() == 1 {
                return Ok(inner.segments[0].get_seal_bytes());
            }
            let mut out = Vec::new();
            for seg in &inner.segments {
                out.extend_from_slice(&seg.get_seal_bytes());
            }
            Ok(out)
        }
        InnerReceipt::Fake(_) => Ok(Vec::new()),
        _ => Err(anyhow!("unsupported receipt type for seal extraction")),
    }
}