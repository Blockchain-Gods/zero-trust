// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use methods::{
     GUEST_ZEROTRUST_ZKVM_ID
};
// use risc0_zkvm::{default_prover, ExecutorEnv};

// host/src/main.rs
use actix_cors::Cors;
use actix_web::{middleware::Logger, web, App, HttpResponse, HttpServer, Result};
use hex::encode as hex_encode;
use serde::{Deserialize, Serialize};
use std::time::Instant;

use host::{digest_to_bytes,
    fetch_bot_config_from_stellar, prove_game, ActionEntry, ProveInput, JOURNAL_LEN,
};

// ─── Request / Response types ─────────────────────────────────────────────────

#[derive(Debug, Deserialize)]
struct ProveRequest {
    /// sha256(player_pubkey + bot_type_lowercase) — acts as challenge_id and seed
    challenge_id: String, // 64-char hex
    /// 64-char hex Stellar Ed25519 public key (raw 32 bytes)
    player_pubkey: String,
    /// token_id of the bot NFT on-chain
    bot_config_id: u32,
    /// Private defender action log
    action_log: Vec<ActionEntry>,
}

#[derive(Debug, Serialize)]
struct ProveResponse {
    success: bool,
    proof_verified: bool,
    execution_time_ms: u128,

    // Artifacts the FE needs to call the Stellar verifier contract
    #[serde(skip_serializing_if = "Option::is_none")]
    seal_hex: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    image_id_hex: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    journal_sha256_hex: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    journal_bytes_hex: Option<String>,

    // Decoded journal for FE display / leaderboard
    #[serde(skip_serializing_if = "Option::is_none")]
    journal: Option<JournalResponse>,

    #[serde(skip_serializing_if = "Option::is_none")]
    error: Option<String>,
}

/// Decoded journal fields returned to the FE for display purposes.
#[derive(Debug, Serialize)]
struct JournalResponse {
    challenge_id: String, // hex
    player_pubkey: String,
    bot_config_id: u32,
    threats_cured: u32,
    systems_destroyed: u32,
    data_leaked_x100: u32,
    score: u32,
    duration_ms: u32,
    accuracy_bps: u32,
}

#[derive(Debug, Serialize)]
struct HealthResponse {
    status: String,
    image_id_hex: String,
    version: String,
}

// ─── Helpers ──────────────────────────────────────────────────────────────────

fn image_id_hex() -> String {

    hex_encode(digest_to_bytes(GUEST_ZEROTRUST_ZKVM_ID.into()))
}

fn error_response(
    msg: impl Into<String>,
    start: Instant,
) -> HttpResponse {
    HttpResponse::InternalServerError().json(ProveResponse {
        success: false,
        proof_verified: false,
        execution_time_ms: start.elapsed().as_millis(),
        seal_hex: None,
        image_id_hex: None,
        journal_sha256_hex: None,
        journal_bytes_hex: None,
        journal: None,
        error: Some(msg.into()),
    })
}

fn bad_request(msg: impl Into<String>, start: Instant) -> HttpResponse {
    HttpResponse::BadRequest().json(ProveResponse {
        success: false,
        proof_verified: false,
        execution_time_ms: start.elapsed().as_millis(),
        seal_hex: None,
        image_id_hex: None,
        journal_sha256_hex: None,
        journal_bytes_hex: None,
        journal: None,
        error: Some(msg.into()),
    })
}

fn parse_hex_32(s: &str) -> anyhow::Result<[u8; 32]> {
    let bytes = hex::decode(s.trim_start_matches("0x"))?;
    if bytes.len() != 32 {
        anyhow::bail!("expected 32-byte hex, got {} bytes", bytes.len());
    }
    let mut out = [0u8; 32];
    out.copy_from_slice(&bytes);
    Ok(out)
}

// ─── Endpoints ────────────────────────────────────────────────────────────────

async fn health() -> Result<HttpResponse> {
    Ok(HttpResponse::Ok().json(HealthResponse {
        status: "healthy".to_string(),
        image_id_hex: image_id_hex(),
        version: "1.0.0".to_string(),
    }))
}

async fn get_image_id() -> Result<HttpResponse> {
    #[derive(Serialize)]
    struct Resp { image_id_hex: String }
    Ok(HttpResponse::Ok().json(Resp { image_id_hex: image_id_hex() }))
}

async fn prove(req: web::Json<ProveRequest>) -> Result<HttpResponse> {
    let start = Instant::now();

    // ── Validate player_pubkey ────────────────────────────────────────────────
    let player_pubkey = match parse_hex_32(&req.player_pubkey) {
        Ok(k) => k,
        Err(e) => return Ok(bad_request(format!("invalid player_pubkey: {}", e), start)),
    };

    // ── Validate challenge_id (must be 32-byte hex) ───────────────────────────
    let challenge_id_bytes = match parse_hex_32(&req.challenge_id) {
        Ok(b) => b,
        Err(e) => return Ok(bad_request(format!("invalid challenge_id: {}", e), start)),
    };
    // Store first 4 bytes as u32 for journal — full hash is in player_pubkey + bot seed
    let challenge_id = u32::from_le_bytes(challenge_id_bytes[..4].try_into().unwrap());

    // ── Validate action log ───────────────────────────────────────────────────
    if req.action_log.is_empty() {
        return Ok(bad_request("action_log must not be empty", start));
    }
    for (i, entry) in req.action_log.iter().enumerate() {
        if entry.unassigned_at_ms <= entry.assigned_at_ms {
            return Ok(bad_request(
                format!(
                    "action_log[{}]: unassigned_at_ms ({}) must be > assigned_at_ms ({})",
                    i, entry.unassigned_at_ms, entry.assigned_at_ms
                ),
                start,
            ));
        }
    }

    // ── Fetch bot config from Stellar ─────────────────────────────────────────
    let bot_config = match fetch_bot_config_from_stellar(req.bot_config_id).await {
        Ok(cfg) => cfg,
        Err(e) => {
            return Ok(error_response(
                format!("failed to fetch bot config (token_id={}): {}", req.bot_config_id, e),
                start,
            ))
        }
    };

    log::info!("Fetched bot config: {:?}", bot_config);


    // ── Build prove input ─────────────────────────────────────────────────────
    let input = ProveInput {
        challenge_id,
        player_pubkey,
        bot_config_id: req.bot_config_id,
        bot_config,
        action_log: req.action_log.clone(),
    };

    log::info!("Submitting to prover thread pool...");
    // ── Prove (blocking — spawn on thread pool) ───────────────────────────────
    let prove_result = match actix_web::web::block(move || prove_game(&input)).await {
        Ok(Ok(r)) => {
        log::info!("Proof complete in {}ms", start.elapsed().as_millis());
        r
    },
    Ok(Err(e)) => return Ok(error_response(format!("proof generation failed: {}", e), start)),
   Err(e) => return Ok(error_response(format!("thread pool error: {}", e), start)),
    };

    // ── Build response ────────────────────────────────────────────────────────
    let j = &prove_result.journal;

    let journal_resp = JournalResponse {
        challenge_id: hex_encode(&prove_result.journal_bytes[0..4]),
        player_pubkey: hex_encode(j.player_pubkey),
        bot_config_id: j.bot_config_id,
        threats_cured: j.threats_cured,
        systems_destroyed: j.systems_destroyed,
        data_leaked_x100: j.data_leaked_x100,
        score: j.score,
        duration_ms: j.duration_ms,
        accuracy_bps: j.accuracy_bps,
    };

    Ok(HttpResponse::Ok().json(ProveResponse {
        success: true,
        proof_verified: true,
        execution_time_ms: start.elapsed().as_millis(),
        seal_hex: Some(format!("0x{}", hex_encode(&prove_result.seal))),
        image_id_hex: Some(hex_encode(prove_result.image_id)),
        journal_sha256_hex: Some(hex_encode(prove_result.journal_sha256)),
        journal_bytes_hex: Some(format!("0x{}", hex_encode(&prove_result.journal_bytes))),
        journal: Some(journal_resp),
        error: None,
    }))
}

// ─── Main ─────────────────────────────────────────────────────────────────────

#[actix_web::main]
async fn main() -> std::io::Result<()> {
    dotenv::dotenv().ok();
    env_logger::init();

    println!("Zero Trust — RISC Zero Host");
    println!("Image ID: {}", image_id_hex());

    HttpServer::new(|| {
        let cors = Cors::default()
            .allow_any_origin()
            .allow_any_method()
            .allow_any_header()
            .max_age(3600);

        App::new()
            .wrap(Logger::default())
            .wrap(cors)
            .route("/health", web::get().to(health))
            .route("/image-id", web::get().to(get_image_id))
            .route("/prove", web::post().to(prove))
    })
    .bind("127.0.0.1:8080")?
    .run()
    .await
}